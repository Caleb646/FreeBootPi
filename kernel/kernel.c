#include "kernel.h"
#include "arm/sysregs.h"
#include "base.h"
#include "dma.h"
#include "irq.h"
#include "mem.h"
#include "peripherals/uart.h"
#include "screen.h"
#include "sync.h"
#include "timer.h"
#include "usb/usb3.h"

const char* entry_error_messages[] = {
    "SYNC_INVALID_EL1t",   "IRQ_INVALID_EL1t",
    "FIQ_INVALID_EL1t",    "ERROR_INVALID_EL1t",

    "SYNC_INVALID_EL1h",   "IRQ_INVALID_EL1h",
    "FIQ_INVALID_EL1h",    "ERROR_INVALID_EL1h",

    "SYNC_INVALID_EL0_64", "IRQ_INVALID_EL0_64",
    "FIQ_INVALID_EL0_64",  "ERROR_INVALID_EL0_64",

    "SYNC_INVALID_EL0_32", "IRQ_INVALID_EL0_32",
    "FIQ_INVALID_EL0_32",  "ERROR_INVALID_EL0_32"
};

// https://developer.arm.com/documentation/ddi0595/2020-12/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-
/*
 * \brief Return the error for the exception class field in
 *   the ESR register. Bits 31:26
 */
static char const* esr_ec2str (u32 esr) {
    switch ((esr >> 26) & 0x3F) {
    case 0b000000: return "Unknown";
    case 0b000111:
        return "Trapped SVE, Advanced SIMD, or Floating Point Instruction";
    case 0b001010:
        return "Trapped LD64B, ST64B, ST64BV, or ST64BV0 Instruction";
    case 0b001101: return "Branch Target Exception";
    case 0b001110: return "Illegal Execution State";
    case 0b010001: return "SVC instruction execution in AArch32 state";
    case 0b010101: return "SVC instruction execution in AArch64 state";
    case 0b011100:
        return "Exception from a Pointer Authentication instruction "
               "authentication failure";
    /*
     * Used for MMU faults generated by instruction accesses and synchronous External aborts,
     * including synchronous parity or ECC errors. Not used for debug-related exceptions.
     */
    case 0b100000: return "Instruction Abort from a lower Exception level";
    /*
     * Used for MMU faults generated by instruction accesses and synchronous External aborts,
     * including synchronous parity or ECC errors. Not used for debug-related exceptions.
     */
    case 0b100001:
        return "Instruction Abort taken without a change in Exception level";
    case 0b100010: return "PC alignment fault exception";
    /*
     * Used for MMU faults generated by instruction accesses and synchronous External aborts,
     * including synchronous parity or ECC errors. Not used for debug-related exceptions.
     */
    case 0b100100: return "Data Abort from a lower Exception level";
    /*
     * Used for MMU faults generated by instruction accesses and synchronous External aborts,
     * including synchronous parity or ECC errors. Not used for debug-related exceptions.
     */
    case 0b100101:
        return "Data Abort taken without a change in Exception level";
    case 0b100110: return "SP alignment fault exception";
    default: return "Unlisted";
    }
}

void show_invalid_entry_message (s32 type, u32 esr, u32 address) {
    LOG_ERROR ("Type: [%s] EC: [%s] Address: [%x]", entry_error_messages[type], esr_ec2str (esr), address);
}

void kernel_main (void) {
    init_printf (0, putc);
    LOG_DEBUG ("Exception Level: [0x%X]", get_arm_exception_lvl ());
    LOG_DEBUG ("Kernel Start [0x%X] Kernel End [0x%X]", (u32)KERNEL_START_ADDR, (u32)KERNEL_END_ADDR);
    extern uintptr_t __bss_start;
    extern uintptr_t __bss_end;
    LOG_DEBUG ("bss start [0x%X] bss end [0x%X]", (u32)(u64)&__bss_start, (u32)(u64)&__bss_end);
    LOG_DEBUG ("PCIe virtual start [0x%X] PCIe virtual end [0x%X]", MEM_PCIE_RANGE_START_VIRTUAL, MEM_PCIE_RANGE_END_VIRTUAL);

    irq_init ();
    timer_init (VC_GIC_SYSTEM_TIMER_IRQ_3);
    // Data Cache should be invalidated on reset and startup.
    // L1 cache for secondary cores should be as well.
    cache_invalidate ();
    mem_init (NULLPTR);

    // u64 value;
    // for (uintptr_t addr = 0x89ddc; addr < 0x90000; addr += 8) {
    //     value = *(u64*)addr;
    //     LOG_INFO ("0x%X", (u32)addr);
    // }

    xhci_device_t* device = xhci_device_create ();
    bool status           = xhci_device_init (device);
    (void)status;

    dma_init (NULLPTR);
    screen_init ();
    screen_draw_string (512, 512, WHITE, "Hello World");
    screen_draw_rect (0, 0, 200, 200, WHITE);
    while (1) {
        // u8* ptr = (u8*)malloc(sizeof(size_t));
        // u8* ptr2 = (u8*)malloc(sizeof(size_t));
        // LOG_DEBUG("Address: [%X]  [%X] [%u]", ptr, ptr2, sizeof(node_t));
        // free(ptr);
        // screen_draw_rect (500, 500, 50, 50, WHITE);
        LOG_DEBUG ("Tick");
        screen_update ();
        wait_ms (1000); //
    }
}
